package exploit

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"strings"

	"bug/modules/config"
	"bug/modules/utils"
)

type Vulnerability struct {
	ID   int64
	Name string
}

type SearchsploitResult struct {
	Title  string `json:"Title"`
	EDB_ID string `json:"EDB-ID"`
	Path   string `json:"Path"`
}

type SearchsploitResults struct {
	Results []SearchsploitResult `json:"RESULTS_EXPLOIT"`
}

// RunExploitResearch orchestrates the exploit research workflow.
func RunExploitResearch(cfg *config.Config, db *sql.DB) {
	options := utils.Options{
		Output:  cfg.Workspace,
		Threads: cfg.Recon.Threads,
	}
	utils.Banner("Starting Exploit Research phase")

	vulns, err := getVulnerabilities(db)
	if err != nil {
		utils.Error("Could not retrieve vulnerabilities from database", err)
		return
	}

	if len(vulns) == 0 {
		utils.Warn("No vulnerabilities found in database to research. Run the 'scan' module first.")
		return
	}

	var totalExploitsFound int
	for _, vuln := range vulns {
		utils.Log(fmt.Sprintf("Researching exploits for: %s", vuln.Name))
		exploits, err := runSearchsploit(vuln.Name, options)
		if err != nil {
			utils.Warn(fmt.Sprintf("Exploit search failed for '%s': %v", vuln.Name, err))
			continue
		}

		if len(exploits) > 0 {
			utils.Success(fmt.Sprintf("Found %d potential exploits for '%s'", len(exploits), vuln.Name))
			totalExploitsFound += len(exploits)
			for _, exploit := range exploits {
				_, err := db.Exec(`INSERT INTO exploits (vulnerability_id, title, edb_id, path)
								  VALUES (?, ?, ?, ?)`,
					vuln.ID, exploit.Title, exploit.EDB_ID, exploit.Path)
				if err != nil {
					utils.Warn(fmt.Sprintf("Failed to insert exploit '%s': %v", exploit.Title, err))
				}
			}
		}
	}
	utils.Success(fmt.Sprintf("Exploit research complete. Found %d total potential exploits.", totalExploitsFound))
}

func getVulnerabilities(db *sql.DB) ([]Vulnerability, error) {
	rows, err := db.Query("SELECT id, name FROM vulnerabilities")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var vulns []Vulnerability
	for rows.Next() {
		var v Vulnerability
		if err := rows.Scan(&v.ID, &v.Name); err != nil {
			return nil, err
		}
		vulns = append(vulns, v)
	}
	return vulns, nil
}

func runSearchsploit(query string, options utils.Options) ([]SearchsploitResult, error) {
	// Searchsploit can be noisy, so we don't use the global logger for the command itself.
	output, err := utils.RunCommandAndCapture(options, "searchsploit", "--json", query)
	if err != nil {
		// It returns an error if no results are found, so we check for that.
		if strings.Contains(err.Error(), "No Results") || strings.Contains(err.Error(), "exit status 1") {
			return []SearchsploitResult{}, nil // Not a true error, just no exploits.
		}
		return nil, err
	}

	var results SearchsploitResults
	if err := json.Unmarshal([]byte(output), &results); err != nil {
		return nil, fmt.Errorf("failed to parse searchsploit JSON: %w", err)
	}

	return results.Results, nil
} 